diff --git a/src/crypto/issue21104_test.go b/src/crypto/issue21104_test.go
index 46620887999..93a51891e96 100644
--- a/src/crypto/issue21104_test.go
+++ b/src/crypto/issue21104_test.go
@@ -7,10 +7,10 @@ package crypto_test
 import (
 	"crypto/aes"
 	"crypto/cipher"
-	"crypto/rc4"
 	"testing"
 )
 
+/*
 func TestRC4OutOfBoundsWrite(t *testing.T) {
 	// This cipherText is encrypted "0123456789"
 	cipherText := []byte{238, 41, 187, 114, 151, 2, 107, 13, 178, 63}
@@ -20,6 +20,8 @@ func TestRC4OutOfBoundsWrite(t *testing.T) {
 	}
 	test(t, "RC4", cipherText, cipher.XORKeyStream)
 }
+*/
+
 func TestCTROutOfBoundsWrite(t *testing.T) {
 	testBlock(t, "CTR", cipher.NewCTR)
 }
diff --git a/src/crypto/md5/example_test.go b/src/crypto/md5/example_test.go
index af8c1bfd65a..ea68949888f 100644
--- a/src/crypto/md5/example_test.go
+++ b/src/crypto/md5/example_test.go
@@ -1,3 +1,5 @@
+//go:build exclude
+
 // Copyright 2013 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
diff --git a/src/crypto/md5/gen.go b/src/crypto/md5/gen.go
index cd2700a5cfe..a48f74bc2ea 100644
--- a/src/crypto/md5/gen.go
+++ b/src/crypto/md5/gen.go
@@ -1,9 +1,9 @@
+//go:build exclude
+
 // Copyright 2012 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build ignore
-
 // This program generates md5block.go
 // Invoke as
 //
diff --git a/src/crypto/md5/md5.go b/src/crypto/md5/md5.go
index 83e9e4c07a0..af7b0b2d5fd 100644
--- a/src/crypto/md5/md5.go
+++ b/src/crypto/md5/md5.go
@@ -4,6 +4,8 @@
 
 //go:generate go run gen.go -output md5block.go
 
+//go:build exclude
+
 // Package md5 implements the MD5 hash algorithm as defined in RFC 1321.
 //
 // MD5 is cryptographically broken and should not be used for secure
diff --git a/src/crypto/md5/md5_test.go b/src/crypto/md5/md5_test.go
index 851e7fb10d4..b8dfe97525b 100644
--- a/src/crypto/md5/md5_test.go
+++ b/src/crypto/md5/md5_test.go
@@ -1,3 +1,5 @@
+//go:build exclude
+
 // Copyright 2009 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
diff --git a/src/crypto/md5/md5block.go b/src/crypto/md5/md5block.go
index 4ff289e860f..7e751c18188 100644
--- a/src/crypto/md5/md5block.go
+++ b/src/crypto/md5/md5block.go
@@ -1,7 +1,7 @@
+ //go:build exclude
 // Copyright 2013 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
-
 // Code generated by go run gen.go -output md5block.go; DO NOT EDIT.
 
 package md5
diff --git a/src/crypto/md5/md5block_decl.go b/src/crypto/md5/md5block_decl.go
index 3664542fb92..cc63106e188 100644
--- a/src/crypto/md5/md5block_decl.go
+++ b/src/crypto/md5/md5block_decl.go
@@ -1,9 +1,9 @@
+//go:build exclude
+
 // Copyright 2013 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build (amd64 || 386 || arm || ppc64le || ppc64 || s390x || arm64) && !purego
-
 package md5
 
 const haveAsm = true
diff --git a/src/crypto/md5/md5block_generic.go b/src/crypto/md5/md5block_generic.go
index 43cfebd38a9..ac9199ffc3a 100644
--- a/src/crypto/md5/md5block_generic.go
+++ b/src/crypto/md5/md5block_generic.go
@@ -1,9 +1,9 @@
+//go:build exclude
+
 // Copyright 2014 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build (!amd64 && !386 && !arm && !ppc64le && !ppc64 && !s390x && !arm64) || purego
-
 package md5
 
 const haveAsm = false
diff --git a/src/crypto/rc4/rc4.go b/src/crypto/rc4/rc4.go
index 67452ec39f0..21a5d110413 100644
--- a/src/crypto/rc4/rc4.go
+++ b/src/crypto/rc4/rc4.go
@@ -9,6 +9,7 @@
 // applications.
 package rc4
 
+/*
 import (
 	"crypto/internal/alias"
 	"strconv"
@@ -78,3 +79,5 @@ func (c *Cipher) XORKeyStream(dst, src []byte) {
 	}
 	c.i, c.j = i, j
 }
+
+*/
diff --git a/src/crypto/rc4/rc4_test.go b/src/crypto/rc4/rc4_test.go
index e7356aa45de..0676daf66c5 100644
--- a/src/crypto/rc4/rc4_test.go
+++ b/src/crypto/rc4/rc4_test.go
@@ -1,3 +1,5 @@
+//go:build exclude
+
 // Copyright 2009 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
diff --git a/src/crypto/tls/cipher_suites.go b/src/crypto/tls/cipher_suites.go
index 6f5bc37197a..bb9eca30a61 100644
--- a/src/crypto/tls/cipher_suites.go
+++ b/src/crypto/tls/cipher_suites.go
@@ -11,7 +11,6 @@ import (
 	"crypto/des"
 	"crypto/hmac"
 	"crypto/internal/boring"
-	"crypto/rc4"
 	"crypto/sha1"
 	"crypto/sha256"
 	"fmt"
@@ -165,9 +164,9 @@ var cipherSuites = []*cipherSuite{ // TODO: replace with a map, since the order
 	{TLS_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},
 	{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, suiteECDHE, cipher3DES, macSHA1, nil},
 	{TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, 0, cipher3DES, macSHA1, nil},
-	{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, 0, cipherRC4, macSHA1, nil},
-	{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, suiteECDHE, cipherRC4, macSHA1, nil},
-	{TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheECDSAKA, suiteECDHE | suiteECSign, cipherRC4, macSHA1, nil},
+	//{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, 0, cipherRC4, macSHA1, nil},
+	//{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, suiteECDHE, cipherRC4, macSHA1, nil},
+	//{TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheECDSAKA, suiteECDHE | suiteECSign, cipherRC4, macSHA1, nil},
 }
 
 // selectCipherSuite returns the first TLS 1.0â€“1.2 cipher suite from ids which
@@ -415,10 +414,12 @@ func aesgcmPreferred(ciphers []uint16) bool {
 	return false
 }
 
+/*
 func cipherRC4(key, iv []byte, isRead bool) any {
 	cipher, _ := rc4.NewCipher(key)
 	return cipher
 }
+*/
 
 func cipher3DES(key, iv []byte, isRead bool) any {
 	block, _ := des.NewTripleDESCipher(key)
diff --git a/src/crypto/tls/conn_test.go b/src/crypto/tls/conn_test.go
index 5e090a017dc..d2966650d59 100644
--- a/src/crypto/tls/conn_test.go
+++ b/src/crypto/tls/conn_test.go
@@ -229,12 +229,13 @@ func runDynamicRecordSizingTest(t *testing.T, config *Config) {
 	}
 }
 
-func TestDynamicRecordSizingWithStreamCipher(t *testing.T) {
-	config := testConfig.Clone()
-	config.MaxVersion = VersionTLS12
-	config.CipherSuites = []uint16{TLS_RSA_WITH_RC4_128_SHA}
-	runDynamicRecordSizingTest(t, config)
-}
+// func TestDynamicRecordSizingWithStreamCipher(t *testing.T) {
+// 	config := testConfig.Clone()
+// 	config.MaxVersion = VersionTLS12
+// 	config.CipherSuites = []uint16{TLS_RSA_WITH_RC4_128_SHA}f
+
+// 	runDynamicRecordSizingTest(t, config)
+// }
 
 func TestDynamicRecordSizingWithCBC(t *testing.T) {
 	config := testConfig.Clone()
diff --git a/src/crypto/tls/handshake_client_test.go b/src/crypto/tls/handshake_client_test.go
index ee9e79afabf..48845d30cfb 100644
--- a/src/crypto/tls/handshake_client_test.go
+++ b/src/crypto/tls/handshake_client_test.go
@@ -529,16 +529,6 @@ func runClientTestTLS13(t *testing.T, template *clientTest) {
 	runClientTestForVersion(t, template, "TLSv13", "-tls1_3")
 }
 
-func TestHandshakeClientRSARC4(t *testing.T) {
-	test := &clientTest{
-		name: "RSA-RC4",
-		args: []string{"-cipher", "RC4-SHA"},
-	}
-	runClientTestTLS10(t, test)
-	runClientTestTLS11(t, test)
-	runClientTestTLS12(t, test)
-}
-
 func TestHandshakeClientRSAAES128GCM(t *testing.T) {
 	test := &clientTest{
 		name: "AES128-GCM-SHA256",
@@ -873,210 +863,6 @@ func TestResumption(t *testing.T) {
 	t.Run("TLSv13", func(t *testing.T) { testResumption(t, VersionTLS13) })
 }
 
-func testResumption(t *testing.T, version uint16) {
-	if testing.Short() {
-		t.Skip("skipping in -short mode")
-	}
-	serverConfig := &Config{
-		MaxVersion:   version,
-		CipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},
-		Certificates: testConfig.Certificates,
-	}
-
-	issuer, err := x509.ParseCertificate(testRSACertificateIssuer)
-	if err != nil {
-		panic(err)
-	}
-
-	rootCAs := x509.NewCertPool()
-	rootCAs.AddCert(issuer)
-
-	clientConfig := &Config{
-		MaxVersion:         version,
-		CipherSuites:       []uint16{TLS_RSA_WITH_RC4_128_SHA},
-		ClientSessionCache: NewLRUClientSessionCache(32),
-		RootCAs:            rootCAs,
-		ServerName:         "example.golang",
-	}
-
-	testResumeState := func(test string, didResume bool) {
-		t.Helper()
-		_, hs, err := testHandshake(t, clientConfig, serverConfig)
-		if err != nil {
-			t.Fatalf("%s: handshake failed: %s", test, err)
-		}
-		if hs.DidResume != didResume {
-			t.Fatalf("%s resumed: %v, expected: %v", test, hs.DidResume, didResume)
-		}
-		if didResume && (hs.PeerCertificates == nil || hs.VerifiedChains == nil) {
-			t.Fatalf("expected non-nil certificates after resumption. Got peerCertificates: %#v, verifiedCertificates: %#v", hs.PeerCertificates, hs.VerifiedChains)
-		}
-		if got, want := hs.ServerName, clientConfig.ServerName; got != want {
-			t.Errorf("%s: server name %s, want %s", test, got, want)
-		}
-	}
-
-	getTicket := func() []byte {
-		return clientConfig.ClientSessionCache.(*lruSessionCache).q.Front().Value.(*lruSessionCacheEntry).state.ticket
-	}
-	deleteTicket := func() {
-		ticketKey := clientConfig.ClientSessionCache.(*lruSessionCache).q.Front().Value.(*lruSessionCacheEntry).sessionKey
-		clientConfig.ClientSessionCache.Put(ticketKey, nil)
-	}
-	corruptTicket := func() {
-		clientConfig.ClientSessionCache.(*lruSessionCache).q.Front().Value.(*lruSessionCacheEntry).state.session.secret[0] ^= 0xff
-	}
-	randomKey := func() [32]byte {
-		var k [32]byte
-		if _, err := io.ReadFull(serverConfig.rand(), k[:]); err != nil {
-			t.Fatalf("Failed to read new SessionTicketKey: %s", err)
-		}
-		return k
-	}
-
-	testResumeState("Handshake", false)
-	ticket := getTicket()
-	testResumeState("Resume", true)
-	if bytes.Equal(ticket, getTicket()) {
-		t.Fatal("ticket didn't change after resumption")
-	}
-
-	// An old session ticket is replaced with a ticket encrypted with a fresh key.
-	ticket = getTicket()
-	serverConfig.Time = func() time.Time { return time.Now().Add(24*time.Hour + time.Minute) }
-	testResumeState("ResumeWithOldTicket", true)
-	if bytes.Equal(ticket, getTicket()) {
-		t.Fatal("old first ticket matches the fresh one")
-	}
-
-	// Once the session master secret is expired, a full handshake should occur.
-	ticket = getTicket()
-	serverConfig.Time = func() time.Time { return time.Now().Add(24*8*time.Hour + time.Minute) }
-	testResumeState("ResumeWithExpiredTicket", false)
-	if bytes.Equal(ticket, getTicket()) {
-		t.Fatal("expired first ticket matches the fresh one")
-	}
-
-	serverConfig.Time = func() time.Time { return time.Now() } // reset the time back
-	key1 := randomKey()
-	serverConfig.SetSessionTicketKeys([][32]byte{key1})
-
-	testResumeState("InvalidSessionTicketKey", false)
-	testResumeState("ResumeAfterInvalidSessionTicketKey", true)
-
-	key2 := randomKey()
-	serverConfig.SetSessionTicketKeys([][32]byte{key2, key1})
-	ticket = getTicket()
-	testResumeState("KeyChange", true)
-	if bytes.Equal(ticket, getTicket()) {
-		t.Fatal("new ticket wasn't included while resuming")
-	}
-	testResumeState("KeyChangeFinish", true)
-
-	// Age the session ticket a bit, but not yet expired.
-	serverConfig.Time = func() time.Time { return time.Now().Add(24*time.Hour + time.Minute) }
-	testResumeState("OldSessionTicket", true)
-	ticket = getTicket()
-	// Expire the session ticket, which would force a full handshake.
-	serverConfig.Time = func() time.Time { return time.Now().Add(24*8*time.Hour + time.Minute) }
-	testResumeState("ExpiredSessionTicket", false)
-	if bytes.Equal(ticket, getTicket()) {
-		t.Fatal("new ticket wasn't provided after old ticket expired")
-	}
-
-	// Age the session ticket a bit at a time, but don't expire it.
-	d := 0 * time.Hour
-	serverConfig.Time = func() time.Time { return time.Now().Add(d) }
-	deleteTicket()
-	testResumeState("GetFreshSessionTicket", false)
-	for i := 0; i < 13; i++ {
-		d += 12 * time.Hour
-		testResumeState("OldSessionTicket", true)
-	}
-	// Expire it (now a little more than 7 days) and make sure a full
-	// handshake occurs for TLS 1.2. Resumption should still occur for
-	// TLS 1.3 since the client should be using a fresh ticket sent over
-	// by the server.
-	d += 12 * time.Hour
-	if version == VersionTLS13 {
-		testResumeState("ExpiredSessionTicket", true)
-	} else {
-		testResumeState("ExpiredSessionTicket", false)
-	}
-	if bytes.Equal(ticket, getTicket()) {
-		t.Fatal("new ticket wasn't provided after old ticket expired")
-	}
-
-	// Reset serverConfig to ensure that calling SetSessionTicketKeys
-	// before the serverConfig is used works.
-	serverConfig = &Config{
-		MaxVersion:   version,
-		CipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},
-		Certificates: testConfig.Certificates,
-	}
-	serverConfig.SetSessionTicketKeys([][32]byte{key2})
-
-	testResumeState("FreshConfig", true)
-
-	// In TLS 1.3, cross-cipher suite resumption is allowed as long as the KDF
-	// hash matches. Also, Config.CipherSuites does not apply to TLS 1.3.
-	if version != VersionTLS13 {
-		clientConfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_RC4_128_SHA}
-		testResumeState("DifferentCipherSuite", false)
-		testResumeState("DifferentCipherSuiteRecovers", true)
-	}
-
-	deleteTicket()
-	testResumeState("WithoutSessionTicket", false)
-
-	// In TLS 1.3, HelloRetryRequest is sent after incorrect key share.
-	// See https://www.rfc-editor.org/rfc/rfc8446#page-14.
-	if version == VersionTLS13 {
-		deleteTicket()
-		serverConfig = &Config{
-			// Use a different curve than the client to force a HelloRetryRequest.
-			CurvePreferences: []CurveID{CurveP521, CurveP384, CurveP256},
-			MaxVersion:       version,
-			Certificates:     testConfig.Certificates,
-		}
-		testResumeState("InitialHandshake", false)
-		testResumeState("WithHelloRetryRequest", true)
-
-		// Reset serverConfig back.
-		serverConfig = &Config{
-			MaxVersion:   version,
-			CipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},
-			Certificates: testConfig.Certificates,
-		}
-	}
-
-	// Session resumption should work when using client certificates
-	deleteTicket()
-	serverConfig.ClientCAs = rootCAs
-	serverConfig.ClientAuth = RequireAndVerifyClientCert
-	clientConfig.Certificates = serverConfig.Certificates
-	testResumeState("InitialHandshake", false)
-	testResumeState("WithClientCertificates", true)
-	serverConfig.ClientAuth = NoClientCert
-
-	// Tickets should be removed from the session cache on TLS handshake
-	// failure, and the client should recover from a corrupted PSK
-	testResumeState("FetchTicketToCorrupt", false)
-	corruptTicket()
-	_, _, err = testHandshake(t, clientConfig, serverConfig)
-	if err == nil {
-		t.Fatalf("handshake did not fail with a corrupted client secret")
-	}
-	testResumeState("AfterHandshakeFailure", false)
-
-	clientConfig.ClientSessionCache = nil
-	testResumeState("WithoutSessionCache", false)
-
-	clientConfig.ClientSessionCache = &serializingClientCache{t: t}
-	testResumeState("BeforeSerializingCache", false)
-	testResumeState("WithSerializingCache", true)
-}
-
 type serializingClientCache struct {
 	t *testing.T
 
diff --git a/src/internal/pkgbits/encoder.go b/src/internal/pkgbits/encoder.go
index 70a2cbae510..e6097d28ed1 100644
--- a/src/internal/pkgbits/encoder.go
+++ b/src/internal/pkgbits/encoder.go
@@ -6,7 +6,7 @@ package pkgbits
 
 import (
 	"bytes"
-	"crypto/md5"
+	"crypto/sha256"
 	"encoding/binary"
 	"go/constant"
 	"io"
@@ -62,7 +62,7 @@ func NewPkgEncoder(syncFrames int) PkgEncoder {
 // DumpTo writes the package's encoded data to out0 and returns the
 // package fingerprint.
 func (pw *PkgEncoder) DumpTo(out0 io.Writer) (fingerprint [8]byte) {
-	h := md5.New()
+	h := sha256.New()
 	out := io.MultiWriter(out0, h)
 
 	writeUint32 := func(x uint32) {
